# 性能分析与承载能力评估

## 当前性能配置

### HTTP 连接池配置
- **MaxIdleConns**: 100（总连接池大小）
- **MaxIdleConnsPerHost**: 50（每个主机的空闲连接）
- **MaxConnsPerHost**: 100（每个主机的最大并发连接数）
- **IdleConnTimeout**: 90秒（空闲连接超时）
- **Client Timeout**: 30秒（请求超时）

### HTTP 服务器配置
- **ReadTimeout**: 10秒（读取请求超时）
- **WriteTimeout**: 30秒（写入响应超时）
- **IdleTimeout**: 120秒（空闲连接超时）
- **MaxHeaderBytes**: 1MB（最大请求头大小）

## 性能瓶颈分析

### 1. 同步写入模式（主要瓶颈）
- **问题**：每个请求必须等待 Doris Stream Load 完成才能返回
- **影响**：请求响应时间 = 网络延迟 + Doris 处理时间（通常 50-200ms）
- **限制**：单实例理论最大 QPS = 1000 / 平均响应时间(ms)

### 2. 连接池限制
- **MaxConnsPerHost: 100**：每个 Doris BE 节点最多 100 个并发连接
- **影响**：当并发请求超过 100 时，新请求会等待连接释放
- **计算**：如果平均响应时间 100ms，理论最大 QPS = 100 连接 / 0.1秒 = 1000 QPS

### 3. 单实例处理能力
- **Go HTTP Server**：理论上可处理数万并发连接
- **实际限制**：受 Doris 连接池和响应时间限制
- **估算**：单实例约 **500-2000 QPS**（取决于 Doris 响应时间）

## 承载能力估算

### 场景 1：单实例部署
```
假设条件：
- Doris 平均响应时间：100ms
- 连接池：100 并发连接
- 网络延迟：< 10ms

理论最大 QPS = 100 / 0.1 = 1000 QPS
实际可用 QPS（考虑波动）：500-800 QPS
```

### 场景 2：多实例部署（K8s）
```
假设条件：
- 3 个副本（replicaCount: 3）
- 每个实例性能相同
- 负载均衡均匀分配

总承载能力 = 500-800 QPS × 3 = 1500-2400 QPS
```

### 场景 3：高并发场景
```
假设条件：
- 10 个副本
- Doris BE 集群性能良好
- 网络延迟低

总承载能力 = 500-800 QPS × 10 = 5000-8000 QPS
```

## 实际性能表现

### 预期性能指标

| 指标 | 单实例 | 3实例 | 10实例 |
|------|--------|-------|--------|
| **QPS** | 500-800 | 1500-2400 | 5000-8000 |
| **并发连接** | 100 | 300 | 1000 |
| **响应时间** | 50-200ms | 50-200ms | 50-200ms |
| **吞吐量** | ~50KB/s | ~150KB/s | ~500KB/s |

### 影响因素

1. **Doris BE 性能**
   - BE 节点数量和性能
   - 表结构复杂度
   - 数据写入频率

2. **网络延迟**
   - Webhook 到 Doris BE 的网络延迟
   - 内网通常 < 10ms，跨区域可能 50-200ms

3. **请求大小**
   - 当前每个请求约 100-200 字节
   - JSON 解析和序列化开销很小

4. **日志开销**
   - 生产环境建议使用 `LOG_LEVEL=warn` 或 `error`
   - JSON 格式日志对性能影响 < 5%

## 性能优化建议

### 1. 短期优化（无需改代码）

#### 调整连接池大小
```go
// 如果 Doris BE 性能好，可以增加
MaxConnsPerHost: 200  // 从 100 增加到 200
MaxIdleConnsPerHost: 100  // 从 50 增加到 100
```

#### 优化日志级别
```bash
# 生产环境
LOG_LEVEL=warn
LOG_FORMAT=json
DEBUG=false
```

#### 增加实例数
```yaml
# helm/values.yaml
replicaCount: 5  # 根据实际负载调整
```

### 2. 中期优化（需要代码改动）

#### 实现批量写入
- **方案**：收集多个请求，批量写入 Doris
- **效果**：减少网络往返，提升吞吐量 3-5 倍
- **风险**：增加延迟，需要处理失败场景

#### 实现异步写入队列
- **方案**：请求立即返回 202，后台异步写入
- **效果**：响应时间从 100ms 降到 < 10ms
- **风险**：需要处理队列满、数据丢失等场景

#### 连接池预热
- **方案**：启动时预建立连接
- **效果**：减少首次请求延迟

### 3. 长期优化（架构改进）

#### 使用消息队列
- **方案**：Webhook → Kafka/RabbitMQ → 批量写入 Doris
- **效果**：解耦，支持更高吞吐量
- **复杂度**：需要引入消息队列组件

#### 使用 Doris 批量导入 API
- **方案**：使用 Multi Load 或 Broker Load
- **效果**：批量写入性能更好
- **限制**：需要 FE 节点

## 监控指标建议

### 关键指标
1. **QPS**：每秒请求数
2. **响应时间**：P50, P95, P99
3. **错误率**：4xx, 5xx 错误比例
4. **连接池使用率**：当前连接数 / 最大连接数
5. **Doris 写入延迟**：从请求到 Doris 响应的时间

### 告警阈值
- **响应时间 P95 > 500ms**：需要扩容或优化
- **错误率 > 1%**：检查 Doris 状态
- **连接池使用率 > 80%**：考虑增加连接池或实例数

## 压力测试建议

### 使用工具
```bash
# 使用 wrk 或 hey 进行压力测试
wrk -t12 -c400 -d30s -s script.lua http://localhost:8080/video

# 或使用 hey
hey -n 100000 -c 100 -m POST -H "Content-Type: application/json" \
  -d '{"project":"test","event":"play","userAgent":"test"}' \
  http://localhost:8080/video
```

### 测试场景
1. **基准测试**：单实例，逐步增加并发
2. **峰值测试**：模拟突发流量
3. **稳定性测试**：长时间运行，观察内存和连接泄漏

## 总结

### 当前承载能力
- **单实例**：**500-800 QPS**
- **3实例**：**1500-2400 QPS**
- **10实例**：**5000-8000 QPS**

### 适用场景
✅ **中小型应用**：< 1000 QPS  
✅ **中型应用**：1000-5000 QPS（需要多实例）  
⚠️ **大型应用**：> 5000 QPS（建议引入消息队列）

### 性能瓶颈
1. **主要瓶颈**：Doris 同步写入（响应时间 50-200ms）
2. **次要瓶颈**：连接池限制（100 并发连接/实例）

### 优化优先级
1. **高优先级**：增加实例数（最简单有效）
2. **中优先级**：调整连接池大小
3. **低优先级**：实现批量写入或异步队列
